#!/usr/bin/env ruby
#
# prepare git to release to production, supporting two release branches
#
require 'thor'

class Release < Thor
  BRANCHES=%w{code code-rc code-dev beta beta-rc beta-dev}
  desc "init", "create dual release branches, code and beta"
  def init
      BRANCHES.each { |branch| make_tracking_branch(branch) }
  end

  desc "minor", "prepare git to ship code-dev to code-rc and beta-dev to beta-rc"
  def minor
    update_branches
    @resume_message=%Q{If you get a merge conflict, finish the merge and then rerun
      git woe minor.
      It will resume where it left off.
    }
    merge("code-dev","beta-dev")
    merge("beta-dev","beta-rc")
    merge("code-dev","code-rc")
    push_branches
    puts "done."
  end

  desc "major", "both beta-rc and code-rc will be the same at the end of a major release cycle"
  def major
    update_branches
    @resume_message=%Q{If you get a merge conflict, finish the merge and then rerun
      git woe major.
      It will resume where it left off.
    }
    merge("code-dev","beta-dev")
    merge("beta-dev","code-dev")
    merge("beta-dev","beta-rc")
    merge("code-dev","code-rc")
    push_branches
    puts "done."
  end

  desc "ship", "merges -rc branches into code, beta and tags them"
  method_options :skip_tag => :boolean, :aliases => "-s"
  def ship
    update_branches
    @resume_message=%Q{If you get a merge conflict, finish the merge and then rerun
      git woe ship.
      It will resume where it left off.
    }
    merge("code-rc","code-dev")
    merge("code-rc","beta-rc")
    merge("code-rc","beta")
    merge("beta-rc","beta-dev")
    if start("minor")
      tag_branch("code-rc","code",false)
      tag_branch("beta-rc","beta",false)
    end
    merge("beta-rc","beta")
    merge("code-rc","code")
    finish("minor")
    push_branches
    puts "done."
  end

  desc "start_hotfix", "create a hotfix branch"
  method_options :skip_tag => :boolean, :aliases => "-s"
  def start_hotfix
    update_branches
    delete("hotfix")
    checkout("code")
    run("git checkout -b hotfix")
    puts "type 'release finish_hotfix' after committing your changes"
  end

  desc "finish_hotfix", "finish_hotfix to merge the changes back"
  method_options :skip_tag => :boolean, :aliases => "-s"
  def finish_hotfix
    hotfix = next_tag("hotfix",false)
    if start("hotfix")
      tag_branch("hotfix","hotfix", hotfix)
    end
    merge("hotfix","code")
    merge("hotfix","beta")
    merge("hotfix","code-dev")
    merge("hotfix","beta-dev")
    delete("hotfix")
    finish("hotfix")
    push_branches
    checkout("beta")
  end


  # internal methods - cant call from the outside
  no_commands do

    def run(command)
      puts command
      unless system(command)
        puts "FAILED! #{$?.exitstatus}"
        puts @resume_message if @resume_message
        exit($?.exitstatus)
      end
    end

    def make_tracking_branch(branch)
      unless `git branch`.split.include?(branch)
        run("git checkout -t origin/#{branch}")
      end
    end

    def has_tag(tagname) 
      !`git tag -l '#{tagname}'`.split.empty?
    end

    def start(process)
      if has_tag(process)
        false
      else
        run("git tag #{process}") # lightweight tag
        true
      end
    end
    def finish(process)
      run("git tag -d #{process}")
    end
   
    def update_branches
      run("git fetch --tags")
      BRANCHES.each {|branch| update_branch(branch)}
    end

    def update_branch(branch)
      puts "updating branch: #{branch}..."
      run("git checkout #{branch}")
      run("git pull origin #{branch}")
    end

    def push_branches
      run("git push --tags")
      BRANCHES.each {|branch| push_branch(branch)}
    end

    def push_branch(branch)
      checkout(branch)
      run("git push")
    end

    def checkout(branch)
      run("git checkout #{branch}")
    end

    def delete(branch)
      run("git branch -D #{branch}") if exists?(branch)
    end

    def exists?(branch)
      `git branch`.split.include?(branch)
    end

    def tag_branch(source,target,major_release)
      next_tag = next_tag(target,major_release)
      if major_release
        message="major release #{next_tag}: merge from #{source} => #{target}"
      else
        message="minor release #{next_tag}: merge from #{source} => #{target}"
      end
      run("git tag -a #{next_tag} -m '#{message}'")
    end

    def merge(source, target)
      checkout(target)
      run(%Q{git merge -m "merge from #{source} to #{target}" #{source}})
    end
    
    def next_tag(branch,major_release)
      tags = `git tag -l '#{branch}-*'`.split || ["#{branch}-1.0"]
      tag = tags.map {|tag| /\A(#{branch})-(\d+)\.(\d+)\z/.match(tag).to_a}.sort_by {|val| "#{val[2]}.val[3]".to_f}.last
      branch_name=major=minor=""
      (ignore, branch_name, major, minor) = tag
      if(major_release)
        "#{branch_name}-#{major.to_i+1}.0"
      else
        "#{branch_name}-#{major}.#{minor.to_i+1}"
      end
    end
  end
end

Release.start(ARGV)

