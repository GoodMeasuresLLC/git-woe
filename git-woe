#!/usr/bin/env ruby
#
# prepare git to release to production, supporting two release branches
#
require 'thor'
require 'slack-notifier'
# notify to deploy channel
SLACK_WEBHOOK="https://hooks.slack.com/services/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"

class Release < Thor
  BRANCHES=%w{code code-rc code-dev beta beta-rc beta-dev}
  desc "init", "create dual release branches, code and beta"
  def init
      BRANCHES.each { |branch| make_tracking_branch(branch) }
  end

  desc "minor", "prepare git to ship code-dev to code-rc and beta-dev to beta-rc"
  def minor
    start("minor-release")
    update_branches
    @resume_message=%Q{If you get a merge conflict, finish the merge and then rerun
      git woe minor.
      It will resume where it left off.
    }
    merge("code-dev","beta-dev")
    merge("beta-dev","beta-rc")
    merge("code-dev","code-rc")
    push_branches
    puts "done."
  end

  desc "major", "both beta-rc and code-rc will be the same at the end of a major release cycle"
  def major
    start("major-release")
    update_branches
    @resume_message=%Q{If you get a merge conflict, finish the merge and then rerun
      git woe major.
      It will resume where it left off.
    }
    merge("code-dev","beta-dev")
    merge("beta-dev","code-dev")
    merge("beta-dev","beta-rc")
    merge("code-dev","code-rc")
    push_branches
    puts "done."
  end

  desc "ship", "merges -rc branches into code, beta and tags them"
  method_options :skip_tag => :boolean, :aliases => "-s"
  def ship
    update_branches
    @resume_message=%Q{If you get a merge conflict, finish the merge and then rerun
      git woe ship.
      It will resume where it left off.
    }
    merge("code-rc","code-dev")
    merge("code-rc","beta-rc")
    merge("beta-rc","beta")
    merge("beta-rc","beta-dev")
    merge("code-rc","code")
    major_release = has_tag("major-release")
    code_tag = tag_branch("code-rc","code",major_release)
    beta_tag = tag_branch("beta-rc","beta",major_release)
    # do both just to clean up in case of previous failure
    %w(minor-release major-release).each {|name|finish(name)} 
    push_branches
    slack("#{major_release ? 'major release' : 'minor release'} complete. CODE_TAG: #{code_tag} BETA_TAG: #{beta_tag}")
    puts "done."
  end

  desc "start_hotfix", "create a hotfix branch"
  method_options :skip_tag => :boolean, :aliases => "-s"
  def start_hotfix
    update_branches
    delete("hotfix")
    checkout("code")
    run("git checkout -b hotfix")
    puts "type 'git woe finish_hotfix' after committing your changes"
  end

  desc "finish_hotfix", "finish_hotfix to merge the changes back"
  method_options :skip_tag => :boolean, :aliases => "-s"
  def finish_hotfix
    hotfix = next_tag("hotfix",false)
    tag=nil
    if start("hotfix")
      tag=tag_branch("hotfix","hotfix", hotfix)
    end
    merge("hotfix","code")
    merge("hotfix","beta")
    merge("hotfix","code-dev")
    merge("hotfix","beta-dev")
    delete("hotfix")
    finish("hotfix")
    push_branches
    checkout("beta")
    slack("hotfix complete. #{tag}")
  end

  # desc 'test', 'run some test code'
  # def test
  #   tag = '0.1'
  #   puts "has_remote_tag('#{tag}')=#{has_remote_tag(tag)}"
  #   puts "delete_remote_tag('#{tag}')=#{delete_remote_tag(tag)}"
  #   puts "has_remote_tag('#{tag}')=#{has_remote_tag(tag)}"
  # end


  # internal methods - cant call from the outside
  no_commands do

    def run(command)
      puts command
      unless system(command)
        puts "FAILED! #{$?.exitstatus}"
        puts @resume_message if @resume_message
        exit($?.exitstatus)
      end
    end

    def make_tracking_branch(branch)
      unless `git branch`.split.include?(branch)
        run("git checkout -t origin/#{branch}")
      end
    end

    def has_tag(tagname) 
      !`git tag -l '#{tagname}'`.split.empty?
    end

    def delete_tag(tagname)
      `git tag -D '#{tagname}'`
    end

    def has_remote_tag(tagname) 
      !`git ls-remote -q --tags | grep refs/tags/'#{tagname}'`.split.empty?
    end

    def delete_remote_tag(tagname)
      run("git push origin :refs/tags/#{tagname}")
    end

    def start(process)
      if has_tag(process)
        false
      else
        run("git tag #{process}") # lightweight tag
        true
      end
    end
    def finish(process)
      delete_tag(process) if has_tag(process)
      delete_remote_tag(process) if has_remote_tag(process)
    end
   
    def update_branches
      run("git fetch --tags")
      BRANCHES.each {|branch| update_branch(branch)}
    end

    def update_branch(branch)
      puts "updating branch: #{branch}..."
      run("git checkout #{branch}")
      run("git pull origin #{branch}")
    end

    def push_branches
      run("git push --tags")
      BRANCHES.each {|branch| push_branch(branch)}
    end

    def push_branch(branch)
      checkout(branch)
      run("git push")
    end

    def checkout(branch)
      run("git checkout #{branch}")
    end

    def delete(branch)
      run("git branch -D #{branch}") if exists?(branch)
    end


    def exists?(branch)
      `git branch`.split.include?(branch)
    end

    def tag_branch(source,target,major_release)
      next_tag = next_tag(target,major_release)
      if major_release
        message="major release #{next_tag}: merge from #{source} => #{target}"
      else
        message="minor release #{next_tag}: merge from #{source} => #{target}"
      end
      run("git tag -a #{next_tag} -m '#{message}'")
      next_tag
    end

    def merge(source, target)
      checkout(target)
      run(%Q{git merge -m "merge from #{source} to #{target}" #{source}})
    end
    
    def next_tag(branch,major_release)
      tags = `git tag -l '#{branch}-*'`.split || ["#{branch}-1.0"]
      tag = tags.map {|tag| /\A(#{branch})-(\d+)\.(\d+)\z/.match(tag).to_a}.sort_by {|val| "#{val[2]}.#{val[3]}".to_f}.last
      branch_name=major=minor=""
      (ignore, branch_name, major, minor) = tag
      if(major_release)
        "#{branch_name}-#{major.to_i+1}.0"
      else
        "#{branch_name}-#{major}.#{minor.to_i+1}"
      end
    end

    def slack(message)
      @notifier ||= Slack::Notifier.new SLACK_WEBHOOK
      ping_options = {:channel => "#deploy", :username => "Git-woe", :icon_emoji => ':boat:'}
      begin
        @notifier.ping message, ping_options
      rescue => error
        puts error.message
      end
    end
  end
end

Release.start(ARGV)

